"""Inventory management and profit-locking decisions."""

from __future__ import annotations

from dataclasses import dataclass
from decimal import Decimal


@dataclass(slots=True, frozen=True)
class InventoryDecision:
    """Decision generated by inventory manager."""

    action: str
    reason: str
    target_quantity: Decimal
    urgency: int
    reduce_fraction: float


class InventoryManager:
    """
    Manage open inventory with layered profit-taking and trailing protection.

    Profit levels are interpreted as `(return_threshold, fraction_to_reduce)`.
    """

    def __init__(
        self,
        *,
        profit_levels: tuple[tuple[float, float], ...] = ((0.015, 0.25), (0.025, 0.50), (0.040, 1.0)),
        trailing_stop_pct: float = 0.02,
        time_stop_hours: int = 48,
        min_profit_for_time_stop: float = 0.005,
    ) -> None:
        self.profit_levels = tuple(sorted(profit_levels, key=lambda item: item[0]))
        self.trailing_stop_pct = max(0.0, trailing_stop_pct)
        self.time_stop_hours = max(1, time_stop_hours)
        self.min_profit_for_time_stop = max(0.0, min_profit_for_time_stop)
        self._high_water_mark: Decimal | None = None

    def evaluate(
        self,
        *,
        current_price: Decimal,
        avg_entry: Decimal,
        current_quantity: Decimal,
        hours_in_position: int,
    ) -> InventoryDecision:
        """Evaluate whether current inventory should be reduced."""
        if current_quantity <= 0 or avg_entry <= 0 or current_price <= 0:
            self._high_water_mark = None
            return InventoryDecision(
                action="HOLD",
                reason="no_position",
                target_quantity=Decimal("0"),
                urgency=1,
                reduce_fraction=0.0,
            )

        unrealized_return = (current_price - avg_entry) / avg_entry
        if self._high_water_mark is None or current_price > self._high_water_mark:
            self._high_water_mark = current_price

        if self._high_water_mark is not None and unrealized_return >= Decimal(str(self.profit_levels[0][0])):
            drawdown_from_high = (self._high_water_mark - current_price) / self._high_water_mark
            if drawdown_from_high >= Decimal(str(self.trailing_stop_pct)):
                return InventoryDecision(
                    action="REDUCE_ALL",
                    reason=f"inventory_trailing_stop_{self.trailing_stop_pct:.1%}",
                    target_quantity=Decimal("0"),
                    urgency=5,
                    reduce_fraction=1.0,
                )

        for threshold, fraction in reversed(self.profit_levels):
            if unrealized_return >= Decimal(str(threshold)):
                reduce_fraction = max(0.0, min(1.0, float(fraction)))
                reduce_qty = current_quantity * Decimal(str(reduce_fraction))
                target_qty = max(Decimal("0"), current_quantity - reduce_qty)
                action = "REDUCE_ALL" if reduce_fraction >= 0.999 else (
                    "REDUCE_50" if reduce_fraction >= 0.5 else "REDUCE_25"
                )
                return InventoryDecision(
                    action=action,
                    reason=f"inventory_profit_level_{threshold:.1%}",
                    target_quantity=target_qty,
                    urgency=4,
                    reduce_fraction=reduce_fraction,
                )

        if hours_in_position >= self.time_stop_hours and unrealized_return < Decimal(str(self.min_profit_for_time_stop)):
            return InventoryDecision(
                action="REDUCE_ALL",
                reason=f"inventory_time_stop_{self.time_stop_hours}h",
                target_quantity=Decimal("0"),
                urgency=3,
                reduce_fraction=1.0,
            )

        return InventoryDecision(
            action="HOLD",
            reason="inventory_within_parameters",
            target_quantity=current_quantity,
            urgency=1,
            reduce_fraction=0.0,
        )

