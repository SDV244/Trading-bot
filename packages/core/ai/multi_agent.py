"""Multi-agent proposal generation for AI advisor."""

from __future__ import annotations

import asyncio
import json
from dataclasses import dataclass
from math import isfinite
from typing import Any

from packages.core.config import get_settings

_AGENT_SCHEMA = {
    "proposals": [
        {
            "title": "string",
            "proposal_type": "risk_tuning|execution_tuning|grid_tuning|strategy_switch|anomaly_alert",
            "description": "string",
            "diff": {
                "risk": {
                    "per_trade": "number",
                    "max_daily_loss": "number",
                    "max_exposure": "number",
                    "fee_bps": "integer",
                    "slippage_bps": "integer",
                },
                "trading": {
                    "active_strategy": "string",
                    "grid_levels": "integer",
                    "grid_min_spacing_bps": "integer",
                    "grid_max_spacing_bps": "integer",
                    "grid_volatility_blend": "number",
                    "grid_trend_tilt": "number",
                    "grid_take_profit_buffer": "number",
                    "grid_stop_loss_buffer": "number",
                    "grid_recenter_mode": "aggressive|conservative",
                },
            },
            "expected_impact": "string",
            "evidence": {"key": "value"},
            "confidence": "0.0-1.0",
            "priority": "1-5",
        }
    ]
}


@dataclass(slots=True, frozen=True)
class AgentProposal:
    """Proposal generated by one specialized agent."""

    agent_name: str
    title: str
    proposal_type: str
    description: str
    diff: dict[str, Any]
    expected_impact: str
    evidence: dict[str, Any]
    confidence: float
    priority: int
    reasoning: str


class BaseAgent:
    """Base class for all advisor agents."""

    def __init__(self, *, name: str, system_prompt: str) -> None:
        self.name = name
        self.system_prompt = system_prompt

    async def analyze(self, *, context: dict[str, Any], llm_client: Any) -> list[AgentProposal]:
        raw: list[dict[str, Any]] = []
        try:
            raw = await llm_client.generate_structured(
                context=self._build_agent_context(context),
                system_prompt=self.system_prompt,
                schema=_AGENT_SCHEMA,
            )
        except Exception:
            raw = []

        proposals = self._parse(raw)
        if proposals:
            return proposals
        return self._fallback(context)

    def _build_agent_context(self, context: dict[str, Any]) -> dict[str, Any]:
        return context

    def _fallback(self, _context: dict[str, Any]) -> list[AgentProposal]:
        return []

    def _parse(self, raw: list[dict[str, Any]]) -> list[AgentProposal]:
        out: list[AgentProposal] = []
        for item in raw:
            if not isinstance(item, dict):
                continue
            title = str(item.get("title", "")).strip()
            description = str(item.get("description", "")).strip()
            proposal_type = str(item.get("proposal_type", "")).strip().lower()
            diff = item.get("diff", {})
            if not title or not description or not isinstance(diff, dict):
                continue
            confidence = _coerce_confidence(item.get("confidence", 0.0))
            priority_raw = item.get("priority", 3)
            try:
                priority = max(1, min(5, int(priority_raw)))
            except Exception:
                priority = 3
            evidence = item.get("evidence", {})
            if not isinstance(evidence, dict):
                evidence = {"raw": str(evidence)[:400]}
            expected_impact = str(item.get("expected_impact", "")).strip()[:400]
            reasoning = str(item.get("reasoning", "")).strip()[:600]
            out.append(
                AgentProposal(
                    agent_name=self.name,
                    title=title[:180],
                    proposal_type=proposal_type or "anomaly_alert",
                    description=description[:800],
                    diff=diff,
                    expected_impact=expected_impact or "Agent recommends configuration tuning.",
                    evidence=evidence,
                    confidence=confidence,
                    priority=priority,
                    reasoning=reasoning or "Model-ranked proposal.",
                )
            )
        return out


class StrategyAgent(BaseAgent):
    """Agent focused on strategy-level performance tuning."""

    def __init__(self) -> None:
        super().__init__(
            name="strategy_agent",
            system_prompt=(
                "You are a quantitative strategy optimizer for crypto spot-grid trading. "
                "Propose only safe parameter diffs improving Sharpe, drawdown, and win quality."
            ),
        )

    def _build_agent_context(self, context: dict[str, Any]) -> dict[str, Any]:
        return {
            "active_strategy": context.get("active_strategy"),
            "latest_metrics": context.get("latest_metrics"),
            "recent_metrics": context.get("recent_metrics"),
            "strategy_insights": context.get("strategy_insights"),
            "trading_settings": context.get("trading_settings"),
        }

    def _fallback(self, context: dict[str, Any]) -> list[AgentProposal]:
        metrics = context.get("latest_metrics", {}) if isinstance(context.get("latest_metrics"), dict) else {}
        win_rate = float(metrics.get("win_rate", 0.0) or 0.0)
        max_drawdown = float(metrics.get("max_drawdown", 0.0) or 0.0)
        if win_rate < 0.42:
            return [
                AgentProposal(
                    agent_name=self.name,
                    title="Widen grid spacing in weak win-rate regime",
                    proposal_type="grid_tuning",
                    description="Win-rate dropped below target; reduce churn by widening grid spacing.",
                    diff={"trading": {"grid_min_spacing_bps": 38, "grid_max_spacing_bps": 280}},
                    expected_impact="Lower overtrading and improved net expectancy after fees.",
                    evidence={"win_rate": win_rate, "max_drawdown": max_drawdown},
                    confidence=0.70,
                    priority=4,
                    reasoning="Low win-rate usually indicates spacing too tight for current noise regime.",
                )
            ]
        return []


class RiskAgent(BaseAgent):
    """Agent focused on loss containment and exposure controls."""

    def __init__(self) -> None:
        super().__init__(
            name="risk_agent",
            system_prompt=(
                "You are a portfolio risk manager. Prioritize drawdown control, tail protection, "
                "and robust position sizing. Recommend conservative adjustments only."
            ),
        )

    def _build_agent_context(self, context: dict[str, Any]) -> dict[str, Any]:
        return {
            "risk_settings": context.get("risk_settings"),
            "risk_metrics": context.get("risk_metrics"),
            "latest_metrics": context.get("latest_metrics"),
            "regime_analysis": context.get("regime_analysis"),
        }

    def _fallback(self, context: dict[str, Any]) -> list[AgentProposal]:
        metrics = context.get("latest_metrics", {}) if isinstance(context.get("latest_metrics"), dict) else {}
        risk = context.get("risk_settings", {}) if isinstance(context.get("risk_settings"), dict) else {}
        max_drawdown = float(metrics.get("max_drawdown", 0.0) or 0.0)
        per_trade = float(risk.get("per_trade", 0.005) or 0.005)
        if max_drawdown >= 0.08:
            return [
                AgentProposal(
                    agent_name=self.name,
                    title="Reduce per-trade risk under elevated drawdown",
                    proposal_type="risk_tuning",
                    description="Drawdown exceeded 8%; tighten sizing and max exposure.",
                    diff={
                        "risk": {
                            "per_trade": max(0.0015, round(per_trade * 0.75, 5)),
                            "max_exposure": 0.30,
                        }
                    },
                    expected_impact="Lower downside volatility and faster equity recovery.",
                    evidence={"max_drawdown": max_drawdown},
                    confidence=0.82,
                    priority=5,
                    reasoning="Capital preservation dominates when drawdown is elevated.",
                )
            ]
        return []


class MarketAgent(BaseAgent):
    """Agent focused on microstructure + regime pressure."""

    def __init__(self) -> None:
        super().__init__(
            name="market_agent",
            system_prompt=(
                "You are a market microstructure specialist. Use spread, depth, imbalance, "
                "and volatility context to improve grid placement and execution safety."
            ),
        )

    def _build_agent_context(self, context: dict[str, Any]) -> dict[str, Any]:
        return {
            "order_book": context.get("order_book"),
            "market_context": context.get("market_context"),
            "regime_analysis": context.get("regime_analysis"),
            "trading_settings": context.get("trading_settings"),
        }

    def _fallback(self, context: dict[str, Any]) -> list[AgentProposal]:
        order_book = context.get("order_book", {}) if isinstance(context.get("order_book"), dict) else {}
        spread_bps = float(order_book.get("spread_bps", 0.0) or 0.0)
        if spread_bps > 8.0:
            return [
                AgentProposal(
                    agent_name=self.name,
                    title="Widen grid min spacing during wide spreads",
                    proposal_type="execution_tuning",
                    description="Spread widened materially; increase minimum spacing and slippage safety.",
                    diff={
                        "trading": {"grid_min_spacing_bps": 45},
                        "risk": {"slippage_bps": 8},
                    },
                    expected_impact="Reduce adverse fills and noise-triggered churn.",
                    evidence={"spread_bps": spread_bps},
                    confidence=0.68,
                    priority=3,
                    reasoning="Wide spreads degrade grid edge and increase effective cost.",
                )
            ]
        return []


class ExecutionAgent(BaseAgent):
    """Agent focused on fill-quality and slippage optimization."""

    def __init__(self) -> None:
        super().__init__(
            name="execution_agent",
            system_prompt=(
                "You are an execution-quality optimizer. Minimize slippage, improve fill quality, "
                "and adapt execution settings to liquidity conditions."
            ),
        )

    def _build_agent_context(self, context: dict[str, Any]) -> dict[str, Any]:
        return {
            "execution_metrics": context.get("execution_metrics"),
            "order_book": context.get("order_book"),
            "risk_settings": context.get("risk_settings"),
            "trading_settings": context.get("trading_settings"),
        }

    def _fallback(self, context: dict[str, Any]) -> list[AgentProposal]:
        execution = context.get("execution_metrics", {}) if isinstance(context.get("execution_metrics"), dict) else {}
        avg_slippage = float(execution.get("avg_slippage_bps_24h", 0.0) or 0.0)
        expected_slippage = float(execution.get("expected_slippage_bps", 5.0) or 5.0)
        if avg_slippage > expected_slippage + 1.0:
            target = min(15, int(round(avg_slippage + 1)))
            return [
                AgentProposal(
                    agent_name=self.name,
                    title="Adjust slippage estimate to observed fills",
                    proposal_type="execution_tuning",
                    description="Observed slippage exceeded configured expectation in the last 24h.",
                    diff={"risk": {"slippage_bps": target}},
                    expected_impact="More realistic risk sizing and improved execution assumptions.",
                    evidence={
                        "avg_slippage_bps_24h": avg_slippage,
                        "expected_slippage_bps": expected_slippage,
                    },
                    confidence=0.72,
                    priority=4,
                    reasoning="Persistent slippage underestimation biases expected trade quality.",
                )
            ]
        return []


class SentimentAgent(BaseAgent):
    """Agent focused on macro/sentiment extremes and caution modes."""

    def __init__(self) -> None:
        super().__init__(
            name="sentiment_agent",
            system_prompt=(
                "You monitor sentiment and crowding proxies (fear/greed, funding). "
                "Recommend safer configuration shifts under extreme sentiment."
            ),
        )

    def _build_agent_context(self, context: dict[str, Any]) -> dict[str, Any]:
        return {
            "market_context": context.get("market_context"),
            "risk_settings": context.get("risk_settings"),
            "trading_settings": context.get("trading_settings"),
        }

    def _fallback(self, context: dict[str, Any]) -> list[AgentProposal]:
        market = context.get("market_context", {}) if isinstance(context.get("market_context"), dict) else {}
        fear_greed = int(market.get("fear_greed", 50) or 50)
        funding = float(market.get("funding_rate", 0.0) or 0.0)
        if fear_greed >= 80 or fear_greed <= 20 or abs(funding) > 0.0012:
            return [
                AgentProposal(
                    agent_name=self.name,
                    title="Sentiment extreme guardrail tuning",
                    proposal_type="risk_tuning",
                    description="Extreme sentiment/crowding detected; reduce max exposure temporarily.",
                    diff={"risk": {"max_exposure": 0.25}},
                    expected_impact="Lower blow-up risk during sentiment-driven dislocations.",
                    evidence={"fear_greed": fear_greed, "funding_rate": funding},
                    confidence=0.64,
                    priority=3,
                    reasoning="Sentiment extremes raise squeeze and stop-out risk.",
                )
            ]
        return []


class MetaAgent:
    """Ranks and conflict-filters proposals from specialist agents."""

    @staticmethod
    def rank_and_merge(proposals: list[AgentProposal], *, max_items: int = 5) -> list[AgentProposal]:
        if not proposals:
            return []

        deduped: dict[str, AgentProposal] = {}
        for proposal in proposals:
            key = json.dumps(proposal.diff, sort_keys=True, default=str)
            current = deduped.get(key)
            if current is None or (proposal.priority, proposal.confidence) > (
                current.priority,
                current.confidence,
            ):
                deduped[key] = proposal

        ranked = sorted(
            deduped.values(),
            key=lambda proposal: (
                proposal.priority * proposal.confidence,
                proposal.confidence,
                proposal.priority,
            ),
            reverse=True,
        )
        selected: list[AgentProposal] = []
        seen_section_keys: set[tuple[str, str]] = set()
        for proposal in ranked:
            if MetaAgent._conflicts_with_selected(proposal, seen_section_keys):
                continue
            selected.append(proposal)
            for section, values in proposal.diff.items():
                if not isinstance(values, dict):
                    continue
                for key in values:
                    seen_section_keys.add((section, key))
            if len(selected) >= max_items:
                break
        return selected

    @staticmethod
    def _conflicts_with_selected(
        proposal: AgentProposal,
        seen_section_keys: set[tuple[str, str]],
    ) -> bool:
        for section, values in proposal.diff.items():
            if not isinstance(values, dict):
                continue
            for key in values:
                if (section, key) in seen_section_keys:
                    return True
        return False


class MultiAgentCoordinator:
    """Orchestrate multiple specialist agents and return ranked proposals."""

    def __init__(self) -> None:
        settings = get_settings().multiagent
        self.enabled = settings.enabled
        self.max_proposals = settings.max_proposals
        self.min_confidence = settings.min_confidence
        self.use_meta_agent = settings.meta_agent_enabled

        self.agents: list[BaseAgent] = []
        if settings.strategy_agent_enabled:
            self.agents.append(StrategyAgent())
        if settings.risk_agent_enabled:
            self.agents.append(RiskAgent())
        if settings.market_agent_enabled:
            self.agents.append(MarketAgent())
        if settings.execution_agent_enabled:
            self.agents.append(ExecutionAgent())
        if settings.sentiment_agent_enabled:
            self.agents.append(SentimentAgent())

    async def generate_proposals(
        self,
        *,
        context: dict[str, Any],
        llm_client: Any,
    ) -> list[AgentProposal]:
        if not self.enabled or not self.agents:
            return []
        tasks = [
            asyncio.create_task(agent.analyze(context=context, llm_client=llm_client))
            for agent in self.agents
        ]
        gathered = await asyncio.gather(*tasks, return_exceptions=True)

        collected: list[AgentProposal] = []
        for payload in gathered:
            if isinstance(payload, BaseException):
                continue
            for proposal in payload:
                if proposal.confidence >= self.min_confidence:
                    collected.append(proposal)
        if not collected:
            return []
        if self.use_meta_agent:
            return MetaAgent.rank_and_merge(collected, max_items=self.max_proposals)
        ranked = sorted(
            collected,
            key=lambda item: item.priority * item.confidence,
            reverse=True,
        )
        return ranked[: self.max_proposals]


def _coerce_confidence(value: Any) -> float:
    try:
        parsed = float(value)
    except Exception:
        return 0.0
    if not isfinite(parsed):
        return 0.0
    return max(0.0, min(1.0, parsed))
